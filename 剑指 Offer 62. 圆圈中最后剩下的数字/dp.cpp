/*dp
思路：设f(n,m)是0~n-1数组，每次删除第m个元素的问题，返回最后一个元素
那么，先模拟一次删除，删除的是[m-1],剩余的元素是0,1,2,...,m-2, m,m+1,...,n-1
把0~m-2放到右边：m,...,n-1,0,1,2,...,m-2
重组后的数组从m开始，因为m 可能大于 n，所以取余，即从m%n开始
假设f(n-1,m)返回的下标是x：
即0~n-2，经过多次删除，最后剩下[x]。回到上面的数组,可以一一对应：
0   1   2   3   ... n-3 n-2
m+0 m+1 m+2 m+3 ... m-3 m-2
如果已经知道f(n-1,m)返回的是[x]，对应着下面一行的值为x+m，有可能超过n
所以要取余(x+m)%n , 结合上方即为(x+m%n)%n = (x+m)%n = (f(n-1,n)+m)%n
递推公式f(n,m) = (f(n-1,n)+m)%n
*/
class Solution {
public:
    int lastRemaining(int n, int m) {
        int f = 0;
        for (int i = 2; i <= n; ++i) {
            f = (f + m) % i;
        }
        return f;
    }
};
// O(n) O(1)